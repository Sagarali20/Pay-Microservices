using Microsoft.IdentityModel.Tokens;
using System.Security.Cryptography;
using System.Text;

namespace AuthenticationService.Utils
{
    public class EncryptionDeycryption
    {
        private byte[] key = { };
        private byte[] IV = { 0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef };
        public string Decrypt(string stringToDecrypt, string sEncryptionKey)
        {
            byte[] inputByteArray = new byte[stringToDecrypt.Length + 1];
            try
            {
                key = System.Text.Encoding.UTF8.GetBytes(sEncryptionKey);
                DESCryptoServiceProvider des = new DESCryptoServiceProvider();
                inputByteArray = Convert.FromBase64String(stringToDecrypt);
                MemoryStream ms = new MemoryStream();
                CryptoStream cs = new CryptoStream(ms,
                  des.CreateDecryptor(key, IV), CryptoStreamMode.Write);
                cs.Write(inputByteArray, 0, inputByteArray.Length);
                cs.FlushFinalBlock();
                System.Text.Encoding encoding = System.Text.Encoding.UTF8;
                return encoding.GetString(ms.ToArray());
            }
            catch (Exception e)
            {
                return e.Message;
            }
        }

        public string Encrypt(string stringToEncrypt, string SEncryptionKey)
        {
            try                   
            {
                key = System.Text.Encoding.UTF8.GetBytes(SEncryptionKey);
                DESCryptoServiceProvider des = new DESCryptoServiceProvider();
                byte[] inputByteArray = Encoding.UTF8.GetBytes(stringToEncrypt);
                MemoryStream ms = new MemoryStream();
                CryptoStream cs = new CryptoStream(ms,
                  des.CreateEncryptor(key, IV), CryptoStreamMode.Write);
                cs.Write(inputByteArray, 0, inputByteArray.Length);
                cs.FlushFinalBlock();
                return Convert.ToBase64String(ms.ToArray());
            }
            catch (Exception e)
            {
                return e.Message;
            }
        }
    }

    //public class Encryption
    //{
    //    public static string Encrypt(string toEncrypt, bool useHashing)
    //    {
    //        byte[] keyArray;
    //        byte[] toEncryptArray = UTF8Encoding.UTF8.GetBytes(toEncrypt);

    //        System.Configuration.AppSettingsReader settingsReader =
    //                                            new AppSettingsReader();
    //        // Get the key from config file

    //        string key = (string)settingsReader.GetValue("SecurityKey",
    //                                                         typeof(String));
    //        //System.Windows.Forms.MessageBox.Show(key);
    //        //If hashing use get hashcode regards to your key
    //        if (useHashing)
    //        {
    //            MD5CryptoServiceProvider hashmd5 = new MD5CryptoServiceProvider();
    //            keyArray = hashmd5.ComputeHash(UTF8Encoding.UTF8.GetBytes(key));
    //            //Always release the resources and flush data
    //            // of the Cryptographic service provide. Best Practice

    //            hashmd5.Clear();
    //        }
    //        else
    //            keyArray = UTF8Encoding.UTF8.GetBytes(key);

    //        TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
    //        //set the secret key for the tripleDES algorithm
    //        tdes.Key = keyArray;
    //        //mode of operation. there are other 4 modes.
    //        //We choose ECB(Electronic code Book)
    //        tdes.Mode = CipherMode.ECB;
    //        //padding mode(if any extra byte added)

    //        tdes.Padding = PaddingMode.PKCS7;

    //        ICryptoTransform cTransform = tdes.CreateEncryptor();
    //        //transform the specified region of bytes array to resultArray
    //        byte[] resultArray =
    //          cTransform.TransformFinalBlock(toEncryptArray, 0,
    //          toEncryptArray.Length);
    //        //Release resources held by TripleDes Encryptor
    //        tdes.Clear();
    //        //Return the encrypted data into unreadable string format
    //        return Convert.ToBase64String(resultArray, 0, resultArray.Length);
    //    }

    //    public static string Decrypt(string cipherString, bool useHashing)
    //    {
    //        byte[] keyArray;
    //        //get the byte code of the string

    //        byte[] toEncryptArray = Convert.FromBase64String(cipherString);

    //        System.Configuration.AppSettingsReader settingsReader =
    //                                            new AppSettingsReader();
    //        //Get your key from config file to open the lock!
    //        string key = (string)settingsReader.GetValue("SecurityKey",
    //                                                     typeof(String));

    //        if (useHashing)
    //        {
    //            //if hashing was used get the hash code with regards to your key
    //            MD5CryptoServiceProvider hashmd5 = new MD5CryptoServiceProvider();
    //            keyArray = hashmd5.ComputeHash(UTF8Encoding.UTF8.GetBytes(key));
    //            //release any resource held by the MD5CryptoServiceProvider

    //            hashmd5.Clear();
    //        }
    //        else
    //        {
    //            //if hashing was not implemented get the byte code of the key
    //            keyArray = UTF8Encoding.UTF8.GetBytes(key);
    //        }

    //        TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
    //        //set the secret key for the tripleDES algorithm
    //        tdes.Key = keyArray;
    //        //mode of operation. there are other 4 modes. 
    //        //We choose ECB(Electronic code Book)

    //        tdes.Mode = CipherMode.ECB;
    //        //padding mode(if any extra byte added)
    //        tdes.Padding = PaddingMode.PKCS7;

    //        ICryptoTransform cTransform = tdes.CreateDecryptor();
    //        byte[] resultArray = cTransform.TransformFinalBlock(
    //                             toEncryptArray, 0, toEncryptArray.Length);
    //        //Release resources held by TripleDes Encryptor                
    //        tdes.Clear();
    //        //return the Clear decrypted TEXT
    //        return UTF8Encoding.UTF8.GetString(resultArray);
    //    }
    //}

    public class DESEncryptionDecryption
    {
        /// <summary>
        /// This security key should be very complex and Random for encrypting the text. This playing vital role in encrypting the text.
        /// </summary>
        private const string _securityKey = "PiiSTech@2017";


        /// <summary>
        /// This method is used to convert the plain text to Encrypted/Un-Readable Text format.
        /// </summary>
        /// <param name="PlainText">Plain Text to Encrypt before transferring over the network.</param>
        /// <returns>Cipher Text</returns>
        public static string EncryptPlainTextToCipherText(string PlainText)
        {
            //Getting the bytes of Input String.
            byte[] toEncryptedArray = UTF8Encoding.UTF8.GetBytes(PlainText);

            MD5CryptoServiceProvider objMD5CryptoService = new MD5CryptoServiceProvider();

            //Gettting the bytes from the Security Key and Passing it to compute the Corresponding Hash Value.
            byte[] securityKeyArray = objMD5CryptoService.ComputeHash(UTF8Encoding.UTF8.GetBytes(_securityKey));

            //De-allocatinng the memory after doing the Job.
            objMD5CryptoService.Clear();

            var objTripleDESCryptoService = new TripleDESCryptoServiceProvider();

            //Assigning the Security key to the TripleDES Service Provider.
            objTripleDESCryptoService.Key = securityKeyArray;

            //Mode of the Crypto service is Electronic Code Book.
            objTripleDESCryptoService.Mode = CipherMode.ECB;

            //Padding Mode is PKCS7 if there is any extra byte is added.
            objTripleDESCryptoService.Padding = PaddingMode.PKCS7;

            var objCrytpoTransform = objTripleDESCryptoService.CreateEncryptor();

            //Transform the bytes array to resultArray
            byte[] resultArray = objCrytpoTransform.TransformFinalBlock(toEncryptedArray, 0, toEncryptedArray.Length);

            //Releasing the Memory Occupied by TripleDES Service Provider for Encryption.
            objTripleDESCryptoService.Clear();

            //Convert and return the encrypted data/byte into string format.
            var result = Convert.ToBase64String(resultArray, 0, resultArray.Length);
            return Base64UrlEncoder.Encode(result);
        }


        /// <summary>
        /// This method is used to convert the Cipher/Encypted text to Plain Text.
        /// </summary>
        /// <param name="CipherText">Encrypted Text</param>
        /// <returns>Plain/Decrypted Text</returns>
        public static string DecryptCipherTextToPlainText(string CipherText)
        {
            try
            {
                if (string.IsNullOrWhiteSpace(CipherText))
                {
                    return CipherText;
                }

                string Base64String = Base64UrlEncoder.Decode(CipherText);
                byte[] toEncryptArray = Convert.FromBase64String(Base64String);

                MD5CryptoServiceProvider objMD5CryptoService = new MD5CryptoServiceProvider();

                //Gettting the bytes from the Security Key and Passing it to compute the Corresponding Hash Value.
                byte[] securityKeyArray = objMD5CryptoService.ComputeHash(UTF8Encoding.UTF8.GetBytes(_securityKey));

                //De-allocatinng the memory after doing the Job.
                objMD5CryptoService.Clear();

                var objTripleDESCryptoService = new TripleDESCryptoServiceProvider();

                //Assigning the Security key to the TripleDES Service Provider.
                objTripleDESCryptoService.Key = securityKeyArray;

                //Mode of the Crypto service is Electronic Code Book.
                objTripleDESCryptoService.Mode = CipherMode.ECB;

                //Padding Mode is PKCS7 if there is any extra byte is added.
                objTripleDESCryptoService.Padding = PaddingMode.PKCS7;

                var objCrytpoTransform = objTripleDESCryptoService.CreateDecryptor();

                //Transform the bytes array to resultArray
                byte[] resultArray = objCrytpoTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length);

                //Releasing the Memory Occupied by TripleDES Service Provider for Decryption.          
                objTripleDESCryptoService.Clear();

                //Convert and return the decrypted data/byte into string format.
                return UTF8Encoding.UTF8.GetString(resultArray);
            }
            catch (Exception)
            {
                return CipherText;
            }
        }
    }

    public class MD5Encryption
    {
        /// <summary>
        /// take any string and encrypt it using MD5 then
        /// return the encrypted data 
        /// </summary>
        /// <param name="data">input text you will enterd to encrypt it</param>
        /// <returns>return the encrypted text as hexadecimal string</returns>
        public static string GetMD5HashData(string data)
        {
            if (string.IsNullOrWhiteSpace(data))
            {
                return data;
            }
            //create new instance of md5
            MD5 md5 = MD5.Create();

            //convert the input text to array of bytes
            byte[] hashData = md5.ComputeHash(Encoding.Default.GetBytes(data));

            //create new instance of StringBuilder to save hashed data
            StringBuilder returnValue = new StringBuilder();

            //loop for each byte and add it to StringBuilder
            for (int i = 0; i < hashData.Length; i++)
            {
                returnValue.Append(hashData[i].ToString("x"));
            }

            // return hexadecimal string
            return returnValue.ToString();

        }

        /// <summary>
        /// encrypt input text using MD5 and compare it with
        /// the stored encrypted text
        /// </summary>
        /// <param name="inputData">input text you will enterd to encrypt it</param>
        /// <param name="storedHashData">the encrypted text
        ///         stored on file or database ... etc</param>
        /// <returns>true or false depending on input validation</returns>
        public static bool ValidateMD5HashData(string inputData, string storedHashData)
        {
            //hash input text and save it string variable
            string getHashInputData = GetMD5HashData(inputData);

            if (string.Compare(getHashInputData, storedHashData) == 0)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
    }
}
